# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_HK3QqND6sR2t7BjCkgIOCMr-MlOLJ_e
"""

# prompt: 如何读取excel数据

!pip install pandas
!pip install openpyxl
!pip install k-means-constrained
import pandas as pd

# 读取Excel文件
df = pd.read_excel('附件三：新项目任务数据.xls')  # 将'your_file.xlsx'替换为你实际的文件名

from geopy.distance import geodesic

# 定义目标点的经纬度
target_coordinates = (23.1089, 113.2647)

# 计算距离并添加到DataFrame中
df['distance'] = df.apply(lambda row: geodesic((row["latitude"], row["longitude"]), target_coordinates).km, axis=1)

# 打印结果
print(df['distance'].min(), df['distance'].max())

# prompt: 很好！我还需要做另一张图表，我需要画关于price和state的箱型图

import seaborn as sns
import matplotlib.pyplot as plt

# 绘制关于price和state的箱型图
sns.boxplot(x='state', y='price', data=df)
plt.savefig('boxplot.png')

# prompt: 谢谢你！我需要使用kmeans聚类算法对地理位置的经纬度进行聚类

import matplotlib.pyplot as plt
from sklearn.cluster import KMeans

from k_means_constrained import KMeansConstrained
# 提取经纬度数据
coordinates = df[['latitude', 'longitude']].values

# 创建KMeans模型，指定聚类数量
n_clusters = 593  # 替换为你想要的聚类数量
#kmeans = KMeans(n_clusters=n_clusters)
clf = KMeansConstrained(
     n_clusters=593,
     size_min=2,
     size_max=5,
    random_state=0
)
df['cluster']=clf.fit_predict(coordinates)
centers=clf.cluster_centers_
"""
# 对经纬度数据进行聚类
df['cluster'] = kmeans.fit_predict(coordinates)
print(df['cluster'])

centers = kmeans.cluster_centers_
"""







from math import radians, sin, cos, sqrt, atan2
import math
K=61.0474958
i = 0
def CalcDistanceKM(lat1, lon1, lat2, lon2):
  lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])
  dlon = lon2 - lon1
  dlat = lat2 - lat1
  a = sin(dlat / 2) ** 2 + cos(lat1) * cos(lat2) * sin(dlon / 2) ** 2
  c = 2 * atan2(sqrt(a), sqrt(1 - a))
  distance = 6371 * c
  return distance

# 读取会员位置数据
members_df = pd.read_excel('附件二：会员信息数据.xlsx')  # 将'附件二：会员位置数据.xls'替换为你实际的文件名
members_df[['latitude', 'longitude']] = members_df['Position'][1:].str.split(' ', n=1, expand=True)

# Convert latitude and longitude columns to numeric type
members_df['latitude'] = pd.to_numeric(members_df['latitude'])
members_df['longitude'] = pd.to_numeric(members_df['longitude'])

credit_threshold = members_df['Credit'].quantile(0.2)
new_price = {}

for ct in centers:
    member_count = 0
    region_limit = 0
    sum_term = 0
    # 遍历每个会员
    cluster_i_members = df[df['cluster'] == i]
    #print(ct, cluster_i_members)
    n = len(cluster_i_members)
    for _, member in members_df.iloc[1:].iterrows():
        member_coordinates = (member["latitude"], member["longitude"])

        if member_coordinates[0] > 90:
          member_coordinates = (member_coordinates[1], member_coordinates[0])

        # 计算会员与商店之间的距离
        distance = CalcDistanceKM(ct[0], ct[1], member_coordinates[0], member_coordinates[1])

        # 如果会员在商店2km范围内，则计数器加1
        if distance <= 2:
            member_count += 1
            Dj = distance
            Qj = 0.9 if member['Credit'] >= credit_threshold else 1
            sum_term += (Dj / Qj)
    m = member_count
    if m == 0:
      continue
    Pi = K * math.pow(0.95, n-1) * (1/m) * sum_term
    print(sum_term,m)
    # 将商店的会员数量存储到字典中
    new_price[i] = Pi  # 替换"shop_id"为你实际的商店ID列名
    i += 1

print(new_price)
new_price_df = pd.DataFrame(list(new_price.items()), columns=['cluster', 'price'])
new_price_df.to_excel('new_price_ques4.xlsx', index=False)

# prompt: 现在附件1中的内容是每个商店的地理位置，附件2的内容是会员的位置，我需要统计每个商店周围5km的所有会员数量，应该怎么做？

import pandas as pd
from math import radians, sin, cos, sqrt, atan2
import math

# 读取商店位置数据
shops_df = pd.read_excel('附件一：已结束项目任务数据.xls')  # 将'附件一：已结束项目任务数据.xls'替换为你实际的文件名

# 读取会员位置数据
members_df = pd.read_excel('附件二：会员信息数据.xlsx')  # 将'附件二：会员位置数据.xls'替换为你实际的文件名
members_df[['latitude', 'longitude']] = members_df['Position'][1:].str.split(' ', n=1, expand=True)

# Convert latitude and longitude columns to numeric type
members_df['latitude'] = pd.to_numeric(members_df['latitude'])
members_df['longitude'] = pd.to_numeric(members_df['longitude'])

# 初始化一个字典来存储每个商店周围5km的会员数量
shop_member_counts = {}
shop_member_limit = {}
total_limit = members_df["Limit"].iloc[1:].sum()
credit_threshold = members_df['Credit'].quantile(0.2)

def CalcDistanceKM(lat1, lon1, lat2, lon2):
  lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])
  dlon = lon2 - lon1
  dlat = lat2 - lat1
  a = sin(dlat / 2) ** 2 + cos(lat1) * cos(lat2) * sin(dlon / 2) ** 2
  c = 2 * atan2(sqrt(a), sqrt(1 - a))
  distance = 6371 * c

  return distance
# 遍历每个商店

sum_k = 0
num=0
for _, shop in shops_df.iloc[1:].iterrows():
    shop_coordinates = (shop["latitude"], shop["longitude"])
    member_count = 0
    region_limit = 0
    sum_term = 0
    # 遍历每个会员

    for _, member in members_df.iloc[1:].iterrows():
        member_coordinates = (member["latitude"], member["longitude"])

        if member_coordinates[0] > 90:
          member_coordinates = (member_coordinates[1], member_coordinates[0])

        # 计算会员与商店之间的距离
        distance = CalcDistanceKM(shop_coordinates[0], shop_coordinates[1], member_coordinates[0], member_coordinates[1])

        # 如果会员在商店2km范围内，则计数器加1
        if distance <= 2:
            member_count += 1
            region_limit += member["Limit"]
            Dj = distance
            Qj = 0.9 if member['Credit'] >= credit_threshold else 1
            sum_term += (Dj / Qj)
    m = member_count
    if m == 0:
      continue
    n = 1
    num+=1
    Pi = shop['price']
    K = Pi / ((1/m) * sum_term)
    #print(K, sum_term, m)
    # 将商店的会员数量存储到字典中
    shop_member_counts[shop["number"]] = member_count  # 替换"shop_id"为你实际的商店ID列名
    shop_member_limit[shop["number"]] = region_limit/total_limit  # 替换"shop_id"为你实际的商店ID列名
    sum_k += K
print(sum_k/num)



# prompt: n是一个聚类中的任务点个数，我需要根据任务定价：Pi=K*n*e^{-n}*sigma(j=1 to m)*(1/m)*(Dj/Qj)，和K解出PI,应该怎么做

import math

def calculate_price(K, n, distances, qualities):
  """
  Calculates the price Pi based on the given formula.

  Args:
    K: The constant factor.
    n: The number of task points in a cluster.
    distances: A list of distances Dj from the task point to each member j.
    qualities: A list of quality factors Qj for each member j.

  Returns:
    The calculated price Pi.
  """

  sum_term = sum(d / q for d, q in zip(distances, qualities))
  m = len(distances)  # Number of members considered

  price = K * n * math.exp(-n) * (1/m) * sum_term
  return price

# Example usage:
K = 100  # Replace with the actual value of K
n = 5    # Replace with the number of task points in the cluster
distances = [1.2, 3.5, 2.8, 4.1]  # Replace with actual distances
qualities = [0.9, 1.0, 0.8, 0.95]  # Replace with actual quality factors

price = calculate_price(K, n, distances, qualities)
print("Calculated Price (Pi):", price)

import pandas as pd

# Create separate DataFrames for counts and limits
counts_df = pd.DataFrame(list(shop_member_counts.items()), columns=['任务编号', '会员数量'])
limits_df = pd.DataFrame(list(shop_member_limit.items()), columns=['任务编号', '区域内会员限额占比'])

# Merge the two DataFrames on '任务编号'
result_df = pd.merge(counts_df, limits_df, on='任务编号')

# 将结果写入Excel文件
result_df.to_excel('商店会员数量.xlsx', index=False)

import pandas as pd
import numpy as np
Data2=pd.read_excel('data_ques2.xlsx')
#data2=pd.read_excel('附件一：已结束项目任务数据.xls')

from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error

data1 = Data2[Data2['state']==1]
X=data1[['会员数量','区域内会员限额占比']]
Y=data1['任务标价']

X_Train,X_Test,Y_Train,Y_Test=train_test_split(X,Y,test_size=0.2,random_state=42)

RFR=RandomForestRegressor()
RFR.fit(X_Train,Y_Train)
Y_Pred=RFR.predict(X_Test)
Predqua=pd.DataFrame({"实际值":Y_Test,"预测值":Y_Pred})
#print(Predqua)

data0 = Data2[Data2['state']==0]
X_Total=data0[['会员数量','区域内会员限额占比']]
Y_Total_Pred=RFR.predict(X_Total)
print(Y_Total_Pred)
#print("随机森林回归-MSE:%f"% RFRMeanSquaredError)
Y_Total_Pred=pd.DataFrame({"预测值":Y_Total_Pred})
Y_Total_Pred.to_excel('状态为0的预测值.xlsx',index=False)
#print(Y_Total_Pred)

# prompt: 我需要对Y_Total_Pred中的数据绘制箱式图，并求出其与state=1状态数据的交叉熵损失
import seaborn as sns
import matplotlib.pyplot as plt
# 绘制Y_Total_Pred的箱线图
plt.figure()
sns.boxplot(y=Y_Total_Pred['预测值'])
plt.title('Boxplot of Predicted Prices for state=0')
plt.ylabel('Predicted Price')
plt.show()

# 计算交叉熵损失
bins = np.linspace(Y_Train.min(), Y_Train.max(), 10) # 这里将价格分成10个区间，你可以根据需要调整

# 将实际价格和预测价格离散化
Y_Train_discrete = np.digitize(Y_Train, bins)
Y_Total_Pred_discrete = np.digitize(Y_Total_Pred, bins)

import numpy as np
# 首先，我们需要确保Y_Total_Pred_discrete的长度与Y_Train_discrete相同。
# 我们可以通过从Y_Train_discrete中随机抽取样本（有放回）来实现这一点，以匹配Y_Total_Pred_discrete的长度。

# 获取Y_Total_Pred_discrete的长度
length_total_pred = len(Y_Total_Pred_discrete)

# 从Y_Train_discrete中随机抽取样本以匹配长度
Y_Train_discrete_resampled = np.random.choice(Y_Train_discrete, length_total_pred, replace=True)

# 现在，Y_Train_discrete_resampled和Y_Total_Pred_discrete的长度相同。

# KL散度
from scipy.stats import entropy
kl_divergence = entropy(Y_Train_discrete_resampled, Y_Total_Pred_discrete.flatten())
print("KL Divergence:", kl_divergence)

Data1=pd.read_excel('附件一：已结束项目任务数据.xls')
Data1=Data1[Data1['state']==0]
Y_comp=Data1['price']
Y_comp_discrete = np.digitize(Y_comp, bins)
Y_comp_discrete = np.random.choice(Y_Train_discrete_resampled, length_total_pred, replace=True)

kl_divergence = entropy(Y_Train_discrete_resampled, Y_comp_discrete)
print("KL Divergence:", kl_divergence)

# prompt: 我现在想要把三张分别属于原始值state=0,state=1，预测值放在同一张boxplot中，应该怎么做

import pandas as pd
import matplotlib.pyplot as plt
# 读取已结束项目任务数据
Data1 = pd.read_excel('附件一：已结束项目任务数据.xls')

# 提取state=0和state=1的数据
data_state0 = Data1[Data1['state'] == 0]['price']
data_state1 = Data1[Data1['state'] == 1]['price']

# 读取预测值
Y_Total_Pred = pd.read_excel('状态为0的预测值.xlsx')['预测值']

# 创建DataFrame用于绘图
plot_df = pd.DataFrame({
    'State 0': data_state0,
    'State 1': data_state1,
    'Predicted (State 0)': Y_Total_Pred
})

# 绘制箱线图
plt.figure()
sns.boxplot(data=plot_df)
plt.title('Boxplot of Prices for Different States and Prediction')
plt.ylabel('Price')
plt.show()

# prompt: 现在我需要计算新的任务定价：Pi=K*n*e^{-n}*sigma(j=1 to m)*(1/m)*(Dj/Qj)

import math

def calculate_new_price(K, n, distances, qualities):
  """
  Calculates the new task price based on the given formula.

  Args:
    K: A constant factor.
    n: The number of members within 5km of the task location.
    distances: A list of distances from the task location to each of the m nearest completed tasks.
    qualities: A list of quality scores for each of the m nearest completed tasks.

  Returns:
    The calculated new task price.
  """

  sum_term = 0
  m = len(distances)
  for j in range(m):
    sum_term += (distances[j] / qualities[j])

  price = K * n * math.exp(-n) * (1/m) * sum_term
  return price

# Example usage:
K = 100  # Replace with the actual value of K
n = 150  # Replace with the actual number of members within 5km
distances = [10, 15, 20]  # Replace with actual distances to nearest completed tasks
qualities = [4, 3, 5]  # Replace with actual quality scores of nearest completed tasks

new_price = calculate_new_price(K, n, distances, qualities)
print("New task price:", new_price)

# prompt: 现在我需要根据附件1的任务定价：Pi=K*n*e^{-n}*sigma(j=1 to m)*(1/m)*(Dj/Qj)，反解出K, 其中Pi是表中price参数，n取1，m为1个任务点周围2km的任务数量，Dj为1个任务点周围2km的会员到会员的距离，Qj的取值根据附件2 的会员credit参数决定，credit参数的前20%将取Qj=0.9,否则Qj=1

import pandas as pd
from geopy.distance import geodesic  # Import the geodesic function
# 读取数据
tasks_df = pd.read_excel('附件一：已结束项目任务数据.xls')
members_df = pd.read_excel('附件二：会员信息数据.xlsx')

# 计算credit阈值
credit_threshold = members_df['Credit'].quantile(0.2)

def calculate_K(task_row):
  """
  Calculates K for a given task.

  Args:
    task_row: A row from the tasks DataFrame.

  Returns:
    The calculated value of K.
  """

  Pi = task_row['price']
  n = 1  # 固定n为1

  # 找到2km内的任务
  nearby_tasks = tasks_df[
      (tasks_df['latitude'] != task_row['latitude']) &
      (tasks_df['longitude'] != task_row['longitude']) &
      (geodesic((task_row['latitude'], task_row['longitude']), (tasks_df['latitude'], tasks_df['longitude'])).km <= 2)
  ]

  m = len(nearby_tasks)
  if m == 0:
    return None  # 如果没有附近的任务，则无法计算K

  sum_term = 0
  for _, nearby_task in nearby_tasks.iterrows():
    # 找到2km内的会员
    nearby_members = members_df[
        (geodesic((nearby_task['latitude'], nearby_task['longitude']), (members_df['latitude'], members_df['longitude'])).km <= 2)
    ]

    # 计算Dj和Qj
    Dj = nearby_members.apply(lambda row: geodesic((nearby_task['latitude'], nearby_task['longitude']), (row['latitude'], row['longitude'])).km, axis=1).sum()
    Qj = 0.9 if nearby_members['credit'].mean() >= credit_threshold else 1

    sum_term += (Dj / Qj)

  K = Pi / (n * math.exp(-n) * (1/m) * sum_term)
  return K

# 计算每个任务的K值
tasks_df['K'] = tasks_df.apply(calculate_K, axis=1)

# 打印结果
print(tasks_df[['number', 'K']])  # 替换'number'为你实际的任务ID列名

import pandas as pd
df1 = pd.read_excel('附件一：已结束项目任务数据.xls')
state_0_df1 = df1[df1['state'] == 0]
df2 = pd.read_excel('状态为0的预测值.xlsx')
if state_0_df1.shape[0] - df2.shape[0] == 1:
    df2 = pd.concat([df2, pd.DataFrame([[None]], columns=df2.columns)], ignore_index=True)

df1.loc[state_0_df1.index, df2.columns] = df2.values
df1.to_excel('填入后已结束项目任务数据.xlsx', index=False)

